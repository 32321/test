<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>js模块</title>
</head>
<body>
<script>
    /*
    * 放大模式  如果一个模块很大，需要分成几个部分，或者是一个模块继承另一个模块，就需要使用放大模式
    * */
    var module=function (mod) {
        mod.m1=function () {
            console.log("fangdamoshi");
        }
        return mod;
    }(module);    //放大模式  这种方法使模块增加一个方法  ，返回新的模块
    //在浏览器环境中，模块通常是从网上加载的，若未加载完成时，就会使一个空对象，因此使用款放大模式
    //  加个判断  window.module||{}  及这种模式的立即执行函数的参数可以是空对象
    //模块的独立性是模块的重要部分，模块内部最好不与其他的程序产生交互。
    //要使用外部的全局变量，就要把它作为模块的参数显式的输入模块，这样能保持独立性，还使模块之间的依赖性加强

    //js有两个通行的模块规范 CommonJS 和AMD  node.js的模块系统就是根据CommonJS来实现的，在CommonJS中，
    //有一个全局性方法require(),用于加载模块  假设有一个模块 alog.js
    // 就可以这样使用    var module=require("alog");module.a();这样来使用模块提供的功能

    //但是在浏览器环境中，上述的方法在使用模块的方法时要等待algo.js模块加载完成后
    // 才能正常运行，浏览器不支持CommonJS规范，服务器端的模块可以放在本地磁盘，加载时间很短，而
    //浏览器的模块要等待网速   。很难
    //因此浏览器只能使用异步加载，而不使用同步加载。于是AMD规范诞生
    //AMD  异步模块定义 模块的加载不影响后面语句的执行，所有依赖模块的语句都放在回调函数中
    //当模块加载完毕后，这个回调函数才会执行
    //语法
/*                              第一个参数时模块数组   第二个为回调函数
* require([module],function{                 require(["alog"],function(){
*      ...                                              algo.a();
* })                                         })    模块的加载与模块的使用不是同步的，因此不会出现问题
*                                                                       //不会产生浏览器假死
* */
</script>
</body>
</html>